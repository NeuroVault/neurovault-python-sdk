# coding: utf-8

"""
    Neurovault API

    All ur images r belong to us  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from neurovault_sdk import schemas  # noqa: F401


class PatchedCollection(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """


    class MetaOapg:
        
        class properties:
            id = schemas.IntSchema
            url = schemas.StrSchema
            download_url = schemas.StrSchema
            owner = schemas.IntSchema
            contributors = schemas.StrSchema
            owner_name = schemas.StrSchema
            number_of_images = schemas.IntSchema
            
            
            class name(
                schemas.StrSchema
            ):
                pass
            
            
            class DOI(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'DOI':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class authors(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'authors':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class paper_url(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'paper_url':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class journal_name(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'journal_name':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class description(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'description':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class full_dataset_url(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
                    format = 'uri'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'full_dataset_url':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class private(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def all_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            PrivateEnum,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'private':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            add_date = schemas.DateTimeSchema
            modify_date = schemas.DateTimeSchema
            
            
            class doi_add_date(
                schemas.DateTimeBase,
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
                    format = 'date-time'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, datetime, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'doi_add_date':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class type_of_design(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            TypeOfDesignEnum,
                            BlankEnum,
                            NullEnum,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'type_of_design':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class number_of_imaging_runs(
                schemas.IntBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'number_of_imaging_runs':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class number_of_experimental_units(
                schemas.IntBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'number_of_experimental_units':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class length_of_runs(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'length_of_runs':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class length_of_blocks(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'length_of_blocks':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class length_of_trials(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'length_of_trials':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class optimization(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'optimization':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class optimization_method(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'optimization_method':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class subject_age_mean(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'subject_age_mean':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class subject_age_min(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'subject_age_min':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class subject_age_max(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'subject_age_max':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class handedness(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            CollectionHandednessEnum,
                            BlankEnum,
                            NullEnum,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'handedness':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class proportion_male_subjects(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'proportion_male_subjects':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class inclusion_exclusion_criteria(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'inclusion_exclusion_criteria':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class number_of_rejected_subjects(
                schemas.IntBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'number_of_rejected_subjects':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class group_comparison(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'group_comparison':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class group_description(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'group_description':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class scanner_make(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'scanner_make':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class scanner_model(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'scanner_model':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class field_strength(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'field_strength':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class pulse_sequence(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'pulse_sequence':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class parallel_imaging(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'parallel_imaging':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class field_of_view(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'field_of_view':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class matrix_size(
                schemas.IntBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'matrix_size':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class slice_thickness(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'slice_thickness':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class skip_distance(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'skip_distance':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class acquisition_orientation(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'acquisition_orientation':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class order_of_acquisition(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            OrderOfAcquisitionEnum,
                            BlankEnum,
                            NullEnum,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'order_of_acquisition':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class repetition_time(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'repetition_time':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class echo_time(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'echo_time':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class flip_angle(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'flip_angle':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class software_package(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'software_package':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class software_version(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'software_version':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class order_of_preprocessing_operations(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'order_of_preprocessing_operations':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class quality_control(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'quality_control':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_b0_unwarping(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_b0_unwarping':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class b0_unwarping_software(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'b0_unwarping_software':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_slice_timing_correction(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_slice_timing_correction':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class slice_timing_correction_software(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'slice_timing_correction_software':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_motion_correction(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_motion_correction':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class motion_correction_software(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'motion_correction_software':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class motion_correction_reference(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'motion_correction_reference':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class motion_correction_metric(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'motion_correction_metric':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class motion_correction_interpolation(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'motion_correction_interpolation':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_motion_susceptibiity_correction(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_motion_susceptibiity_correction':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_intersubject_registration(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_intersubject_registration':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class intersubject_registration_software(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'intersubject_registration_software':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class intersubject_transformation_type(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            IntersubjectTransformationTypeEnum,
                            BlankEnum,
                            NullEnum,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'intersubject_transformation_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class nonlinear_transform_type(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'nonlinear_transform_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class transform_similarity_metric(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'transform_similarity_metric':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class interpolation_method(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'interpolation_method':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class object_image_type(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'object_image_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class functional_coregistered_to_structural(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'functional_coregistered_to_structural':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class functional_coregistration_method(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'functional_coregistration_method':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class coordinate_space(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            CoordinateSpaceEnum,
                            BlankEnum,
                            NullEnum,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'coordinate_space':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class target_template_image(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'target_template_image':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class target_resolution(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'target_resolution':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_smoothing(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_smoothing':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class smoothing_type(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'smoothing_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class smoothing_fwhm(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'smoothing_fwhm':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class resampled_voxel_size(
                schemas.Float64Base,
                schemas.NumberBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneDecimalMixin
            ):
            
            
                class MetaOapg:
                    format = 'double'
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, decimal.Decimal, int, float, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'resampled_voxel_size':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class intrasubject_model_type(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'intrasubject_model_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class intrasubject_estimation_type(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'intrasubject_estimation_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class intrasubject_modeling_software(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'intrasubject_modeling_software':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class hemodynamic_response_function(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'hemodynamic_response_function':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_temporal_derivatives(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_temporal_derivatives':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_dispersion_derivatives(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_dispersion_derivatives':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_motion_regressors(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_motion_regressors':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_reaction_time_regressor(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_reaction_time_regressor':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_orthogonalization(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_orthogonalization':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class orthogonalization_description(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'orthogonalization_description':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class used_high_pass_filter(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'used_high_pass_filter':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class high_pass_filter_method(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'high_pass_filter_method':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class autocorrelation_model(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'autocorrelation_model':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class group_model_type(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'group_model_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class group_estimation_type(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'group_estimation_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class group_modeling_software(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'group_modeling_software':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class group_inference_type(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            GroupInferenceTypeEnum,
                            BlankEnum,
                            NullEnum,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'group_inference_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class group_model_multilevel(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'group_model_multilevel':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class group_repeated_measures(
                schemas.BoolBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneBoolMixin
            ):
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, bool, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'group_repeated_measures':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class group_repeated_measures_method(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'group_repeated_measures_method':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class nutbrain_hunger_state(
                schemas.ComposedSchema,
            ):
            
            
                class MetaOapg:
                    
                    @classmethod
                    @functools.lru_cache()
                    def one_of(cls):
                        # we need this here to make our import statements work
                        # we must store _composed_schemas in here so the code is only run
                        # when we invoke this method. If we kept this at the class
                        # level we would get an error because the class level
                        # code would be run when this module is imported, and these composed
                        # classes don't exist yet because their module has not finished
                        # loading
                        return [
                            NutbrainHungerStateEnum,
                            BlankEnum,
                            NullEnum,
                        ]
            
            
                def __new__(
                    cls,
                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
                ) -> 'nutbrain_hunger_state':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                        **kwargs,
                    )
            
            
            class nutbrain_food_viewing_conditions(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'nutbrain_food_viewing_conditions':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class nutbrain_food_choice_type(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'nutbrain_food_choice_type':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class nutbrain_taste_conditions(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'nutbrain_taste_conditions':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class nutbrain_odor_conditions(
                schemas.StrBase,
                schemas.NoneBase,
                schemas.Schema,
                schemas.NoneStrMixin
            ):
            
            
                class MetaOapg:
            
            
                def __new__(
                    cls,
                    *args: typing.Union[None, str, ],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'nutbrain_odor_conditions':
                    return super().__new__(
                        cls,
                        *args,
                        _configuration=_configuration,
                    )
            
            
            class communities(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    items = schemas.IntSchema
            
                def __new__(
                    cls,
                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, decimal.Decimal, int, ]], typing.List[typing.Union[MetaOapg.items, decimal.Decimal, int, ]]],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'communities':
                    return super().__new__(
                        cls,
                        arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> MetaOapg.items:
                    return super().__getitem__(i)
            __annotations__ = {
                "id": id,
                "url": url,
                "download_url": download_url,
                "owner": owner,
                "contributors": contributors,
                "owner_name": owner_name,
                "number_of_images": number_of_images,
                "name": name,
                "DOI": DOI,
                "authors": authors,
                "paper_url": paper_url,
                "journal_name": journal_name,
                "description": description,
                "full_dataset_url": full_dataset_url,
                "private": private,
                "add_date": add_date,
                "modify_date": modify_date,
                "doi_add_date": doi_add_date,
                "type_of_design": type_of_design,
                "number_of_imaging_runs": number_of_imaging_runs,
                "number_of_experimental_units": number_of_experimental_units,
                "length_of_runs": length_of_runs,
                "length_of_blocks": length_of_blocks,
                "length_of_trials": length_of_trials,
                "optimization": optimization,
                "optimization_method": optimization_method,
                "subject_age_mean": subject_age_mean,
                "subject_age_min": subject_age_min,
                "subject_age_max": subject_age_max,
                "handedness": handedness,
                "proportion_male_subjects": proportion_male_subjects,
                "inclusion_exclusion_criteria": inclusion_exclusion_criteria,
                "number_of_rejected_subjects": number_of_rejected_subjects,
                "group_comparison": group_comparison,
                "group_description": group_description,
                "scanner_make": scanner_make,
                "scanner_model": scanner_model,
                "field_strength": field_strength,
                "pulse_sequence": pulse_sequence,
                "parallel_imaging": parallel_imaging,
                "field_of_view": field_of_view,
                "matrix_size": matrix_size,
                "slice_thickness": slice_thickness,
                "skip_distance": skip_distance,
                "acquisition_orientation": acquisition_orientation,
                "order_of_acquisition": order_of_acquisition,
                "repetition_time": repetition_time,
                "echo_time": echo_time,
                "flip_angle": flip_angle,
                "software_package": software_package,
                "software_version": software_version,
                "order_of_preprocessing_operations": order_of_preprocessing_operations,
                "quality_control": quality_control,
                "used_b0_unwarping": used_b0_unwarping,
                "b0_unwarping_software": b0_unwarping_software,
                "used_slice_timing_correction": used_slice_timing_correction,
                "slice_timing_correction_software": slice_timing_correction_software,
                "used_motion_correction": used_motion_correction,
                "motion_correction_software": motion_correction_software,
                "motion_correction_reference": motion_correction_reference,
                "motion_correction_metric": motion_correction_metric,
                "motion_correction_interpolation": motion_correction_interpolation,
                "used_motion_susceptibiity_correction": used_motion_susceptibiity_correction,
                "used_intersubject_registration": used_intersubject_registration,
                "intersubject_registration_software": intersubject_registration_software,
                "intersubject_transformation_type": intersubject_transformation_type,
                "nonlinear_transform_type": nonlinear_transform_type,
                "transform_similarity_metric": transform_similarity_metric,
                "interpolation_method": interpolation_method,
                "object_image_type": object_image_type,
                "functional_coregistered_to_structural": functional_coregistered_to_structural,
                "functional_coregistration_method": functional_coregistration_method,
                "coordinate_space": coordinate_space,
                "target_template_image": target_template_image,
                "target_resolution": target_resolution,
                "used_smoothing": used_smoothing,
                "smoothing_type": smoothing_type,
                "smoothing_fwhm": smoothing_fwhm,
                "resampled_voxel_size": resampled_voxel_size,
                "intrasubject_model_type": intrasubject_model_type,
                "intrasubject_estimation_type": intrasubject_estimation_type,
                "intrasubject_modeling_software": intrasubject_modeling_software,
                "hemodynamic_response_function": hemodynamic_response_function,
                "used_temporal_derivatives": used_temporal_derivatives,
                "used_dispersion_derivatives": used_dispersion_derivatives,
                "used_motion_regressors": used_motion_regressors,
                "used_reaction_time_regressor": used_reaction_time_regressor,
                "used_orthogonalization": used_orthogonalization,
                "orthogonalization_description": orthogonalization_description,
                "used_high_pass_filter": used_high_pass_filter,
                "high_pass_filter_method": high_pass_filter_method,
                "autocorrelation_model": autocorrelation_model,
                "group_model_type": group_model_type,
                "group_estimation_type": group_estimation_type,
                "group_modeling_software": group_modeling_software,
                "group_inference_type": group_inference_type,
                "group_model_multilevel": group_model_multilevel,
                "group_repeated_measures": group_repeated_measures,
                "group_repeated_measures_method": group_repeated_measures_method,
                "nutbrain_hunger_state": nutbrain_hunger_state,
                "nutbrain_food_viewing_conditions": nutbrain_food_viewing_conditions,
                "nutbrain_food_choice_type": nutbrain_food_choice_type,
                "nutbrain_taste_conditions": nutbrain_taste_conditions,
                "nutbrain_odor_conditions": nutbrain_odor_conditions,
                "communities": communities,
            }
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["url"]) -> MetaOapg.properties.url: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["download_url"]) -> MetaOapg.properties.download_url: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["owner"]) -> MetaOapg.properties.owner: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["contributors"]) -> MetaOapg.properties.contributors: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["owner_name"]) -> MetaOapg.properties.owner_name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["number_of_images"]) -> MetaOapg.properties.number_of_images: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["DOI"]) -> MetaOapg.properties.DOI: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["authors"]) -> MetaOapg.properties.authors: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["paper_url"]) -> MetaOapg.properties.paper_url: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["journal_name"]) -> MetaOapg.properties.journal_name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["full_dataset_url"]) -> MetaOapg.properties.full_dataset_url: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["private"]) -> MetaOapg.properties.private: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["add_date"]) -> MetaOapg.properties.add_date: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["modify_date"]) -> MetaOapg.properties.modify_date: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["doi_add_date"]) -> MetaOapg.properties.doi_add_date: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["type_of_design"]) -> MetaOapg.properties.type_of_design: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["number_of_imaging_runs"]) -> MetaOapg.properties.number_of_imaging_runs: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["number_of_experimental_units"]) -> MetaOapg.properties.number_of_experimental_units: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["length_of_runs"]) -> MetaOapg.properties.length_of_runs: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["length_of_blocks"]) -> MetaOapg.properties.length_of_blocks: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["length_of_trials"]) -> MetaOapg.properties.length_of_trials: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["optimization"]) -> MetaOapg.properties.optimization: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["optimization_method"]) -> MetaOapg.properties.optimization_method: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["subject_age_mean"]) -> MetaOapg.properties.subject_age_mean: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["subject_age_min"]) -> MetaOapg.properties.subject_age_min: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["subject_age_max"]) -> MetaOapg.properties.subject_age_max: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["handedness"]) -> MetaOapg.properties.handedness: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["proportion_male_subjects"]) -> MetaOapg.properties.proportion_male_subjects: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["inclusion_exclusion_criteria"]) -> MetaOapg.properties.inclusion_exclusion_criteria: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["number_of_rejected_subjects"]) -> MetaOapg.properties.number_of_rejected_subjects: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_comparison"]) -> MetaOapg.properties.group_comparison: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_description"]) -> MetaOapg.properties.group_description: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["scanner_make"]) -> MetaOapg.properties.scanner_make: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["scanner_model"]) -> MetaOapg.properties.scanner_model: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["field_strength"]) -> MetaOapg.properties.field_strength: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["pulse_sequence"]) -> MetaOapg.properties.pulse_sequence: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["parallel_imaging"]) -> MetaOapg.properties.parallel_imaging: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["field_of_view"]) -> MetaOapg.properties.field_of_view: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["matrix_size"]) -> MetaOapg.properties.matrix_size: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["slice_thickness"]) -> MetaOapg.properties.slice_thickness: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["skip_distance"]) -> MetaOapg.properties.skip_distance: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["acquisition_orientation"]) -> MetaOapg.properties.acquisition_orientation: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["order_of_acquisition"]) -> MetaOapg.properties.order_of_acquisition: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["repetition_time"]) -> MetaOapg.properties.repetition_time: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["echo_time"]) -> MetaOapg.properties.echo_time: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["flip_angle"]) -> MetaOapg.properties.flip_angle: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["software_package"]) -> MetaOapg.properties.software_package: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["software_version"]) -> MetaOapg.properties.software_version: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["order_of_preprocessing_operations"]) -> MetaOapg.properties.order_of_preprocessing_operations: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["quality_control"]) -> MetaOapg.properties.quality_control: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_b0_unwarping"]) -> MetaOapg.properties.used_b0_unwarping: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["b0_unwarping_software"]) -> MetaOapg.properties.b0_unwarping_software: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_slice_timing_correction"]) -> MetaOapg.properties.used_slice_timing_correction: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["slice_timing_correction_software"]) -> MetaOapg.properties.slice_timing_correction_software: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_motion_correction"]) -> MetaOapg.properties.used_motion_correction: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["motion_correction_software"]) -> MetaOapg.properties.motion_correction_software: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["motion_correction_reference"]) -> MetaOapg.properties.motion_correction_reference: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["motion_correction_metric"]) -> MetaOapg.properties.motion_correction_metric: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["motion_correction_interpolation"]) -> MetaOapg.properties.motion_correction_interpolation: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_motion_susceptibiity_correction"]) -> MetaOapg.properties.used_motion_susceptibiity_correction: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_intersubject_registration"]) -> MetaOapg.properties.used_intersubject_registration: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["intersubject_registration_software"]) -> MetaOapg.properties.intersubject_registration_software: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["intersubject_transformation_type"]) -> MetaOapg.properties.intersubject_transformation_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["nonlinear_transform_type"]) -> MetaOapg.properties.nonlinear_transform_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["transform_similarity_metric"]) -> MetaOapg.properties.transform_similarity_metric: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["interpolation_method"]) -> MetaOapg.properties.interpolation_method: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["object_image_type"]) -> MetaOapg.properties.object_image_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["functional_coregistered_to_structural"]) -> MetaOapg.properties.functional_coregistered_to_structural: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["functional_coregistration_method"]) -> MetaOapg.properties.functional_coregistration_method: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["coordinate_space"]) -> MetaOapg.properties.coordinate_space: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["target_template_image"]) -> MetaOapg.properties.target_template_image: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["target_resolution"]) -> MetaOapg.properties.target_resolution: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_smoothing"]) -> MetaOapg.properties.used_smoothing: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["smoothing_type"]) -> MetaOapg.properties.smoothing_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["smoothing_fwhm"]) -> MetaOapg.properties.smoothing_fwhm: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["resampled_voxel_size"]) -> MetaOapg.properties.resampled_voxel_size: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["intrasubject_model_type"]) -> MetaOapg.properties.intrasubject_model_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["intrasubject_estimation_type"]) -> MetaOapg.properties.intrasubject_estimation_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["intrasubject_modeling_software"]) -> MetaOapg.properties.intrasubject_modeling_software: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["hemodynamic_response_function"]) -> MetaOapg.properties.hemodynamic_response_function: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_temporal_derivatives"]) -> MetaOapg.properties.used_temporal_derivatives: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_dispersion_derivatives"]) -> MetaOapg.properties.used_dispersion_derivatives: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_motion_regressors"]) -> MetaOapg.properties.used_motion_regressors: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_reaction_time_regressor"]) -> MetaOapg.properties.used_reaction_time_regressor: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_orthogonalization"]) -> MetaOapg.properties.used_orthogonalization: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["orthogonalization_description"]) -> MetaOapg.properties.orthogonalization_description: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["used_high_pass_filter"]) -> MetaOapg.properties.used_high_pass_filter: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["high_pass_filter_method"]) -> MetaOapg.properties.high_pass_filter_method: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["autocorrelation_model"]) -> MetaOapg.properties.autocorrelation_model: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_model_type"]) -> MetaOapg.properties.group_model_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_estimation_type"]) -> MetaOapg.properties.group_estimation_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_modeling_software"]) -> MetaOapg.properties.group_modeling_software: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_inference_type"]) -> MetaOapg.properties.group_inference_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_model_multilevel"]) -> MetaOapg.properties.group_model_multilevel: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_repeated_measures"]) -> MetaOapg.properties.group_repeated_measures: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["group_repeated_measures_method"]) -> MetaOapg.properties.group_repeated_measures_method: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["nutbrain_hunger_state"]) -> MetaOapg.properties.nutbrain_hunger_state: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["nutbrain_food_viewing_conditions"]) -> MetaOapg.properties.nutbrain_food_viewing_conditions: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["nutbrain_food_choice_type"]) -> MetaOapg.properties.nutbrain_food_choice_type: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["nutbrain_taste_conditions"]) -> MetaOapg.properties.nutbrain_taste_conditions: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["nutbrain_odor_conditions"]) -> MetaOapg.properties.nutbrain_odor_conditions: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["communities"]) -> MetaOapg.properties.communities: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "url", "download_url", "owner", "contributors", "owner_name", "number_of_images", "name", "DOI", "authors", "paper_url", "journal_name", "description", "full_dataset_url", "private", "add_date", "modify_date", "doi_add_date", "type_of_design", "number_of_imaging_runs", "number_of_experimental_units", "length_of_runs", "length_of_blocks", "length_of_trials", "optimization", "optimization_method", "subject_age_mean", "subject_age_min", "subject_age_max", "handedness", "proportion_male_subjects", "inclusion_exclusion_criteria", "number_of_rejected_subjects", "group_comparison", "group_description", "scanner_make", "scanner_model", "field_strength", "pulse_sequence", "parallel_imaging", "field_of_view", "matrix_size", "slice_thickness", "skip_distance", "acquisition_orientation", "order_of_acquisition", "repetition_time", "echo_time", "flip_angle", "software_package", "software_version", "order_of_preprocessing_operations", "quality_control", "used_b0_unwarping", "b0_unwarping_software", "used_slice_timing_correction", "slice_timing_correction_software", "used_motion_correction", "motion_correction_software", "motion_correction_reference", "motion_correction_metric", "motion_correction_interpolation", "used_motion_susceptibiity_correction", "used_intersubject_registration", "intersubject_registration_software", "intersubject_transformation_type", "nonlinear_transform_type", "transform_similarity_metric", "interpolation_method", "object_image_type", "functional_coregistered_to_structural", "functional_coregistration_method", "coordinate_space", "target_template_image", "target_resolution", "used_smoothing", "smoothing_type", "smoothing_fwhm", "resampled_voxel_size", "intrasubject_model_type", "intrasubject_estimation_type", "intrasubject_modeling_software", "hemodynamic_response_function", "used_temporal_derivatives", "used_dispersion_derivatives", "used_motion_regressors", "used_reaction_time_regressor", "used_orthogonalization", "orthogonalization_description", "used_high_pass_filter", "high_pass_filter_method", "autocorrelation_model", "group_model_type", "group_estimation_type", "group_modeling_software", "group_inference_type", "group_model_multilevel", "group_repeated_measures", "group_repeated_measures_method", "nutbrain_hunger_state", "nutbrain_food_viewing_conditions", "nutbrain_food_choice_type", "nutbrain_taste_conditions", "nutbrain_odor_conditions", "communities", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> typing.Union[MetaOapg.properties.id, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["url"]) -> typing.Union[MetaOapg.properties.url, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["download_url"]) -> typing.Union[MetaOapg.properties.download_url, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["owner"]) -> typing.Union[MetaOapg.properties.owner, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["contributors"]) -> typing.Union[MetaOapg.properties.contributors, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["owner_name"]) -> typing.Union[MetaOapg.properties.owner_name, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["number_of_images"]) -> typing.Union[MetaOapg.properties.number_of_images, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["DOI"]) -> typing.Union[MetaOapg.properties.DOI, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["authors"]) -> typing.Union[MetaOapg.properties.authors, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["paper_url"]) -> typing.Union[MetaOapg.properties.paper_url, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["journal_name"]) -> typing.Union[MetaOapg.properties.journal_name, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["full_dataset_url"]) -> typing.Union[MetaOapg.properties.full_dataset_url, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["private"]) -> typing.Union[MetaOapg.properties.private, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["add_date"]) -> typing.Union[MetaOapg.properties.add_date, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["modify_date"]) -> typing.Union[MetaOapg.properties.modify_date, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["doi_add_date"]) -> typing.Union[MetaOapg.properties.doi_add_date, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["type_of_design"]) -> typing.Union[MetaOapg.properties.type_of_design, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["number_of_imaging_runs"]) -> typing.Union[MetaOapg.properties.number_of_imaging_runs, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["number_of_experimental_units"]) -> typing.Union[MetaOapg.properties.number_of_experimental_units, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["length_of_runs"]) -> typing.Union[MetaOapg.properties.length_of_runs, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["length_of_blocks"]) -> typing.Union[MetaOapg.properties.length_of_blocks, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["length_of_trials"]) -> typing.Union[MetaOapg.properties.length_of_trials, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["optimization"]) -> typing.Union[MetaOapg.properties.optimization, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["optimization_method"]) -> typing.Union[MetaOapg.properties.optimization_method, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["subject_age_mean"]) -> typing.Union[MetaOapg.properties.subject_age_mean, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["subject_age_min"]) -> typing.Union[MetaOapg.properties.subject_age_min, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["subject_age_max"]) -> typing.Union[MetaOapg.properties.subject_age_max, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["handedness"]) -> typing.Union[MetaOapg.properties.handedness, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["proportion_male_subjects"]) -> typing.Union[MetaOapg.properties.proportion_male_subjects, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["inclusion_exclusion_criteria"]) -> typing.Union[MetaOapg.properties.inclusion_exclusion_criteria, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["number_of_rejected_subjects"]) -> typing.Union[MetaOapg.properties.number_of_rejected_subjects, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_comparison"]) -> typing.Union[MetaOapg.properties.group_comparison, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_description"]) -> typing.Union[MetaOapg.properties.group_description, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["scanner_make"]) -> typing.Union[MetaOapg.properties.scanner_make, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["scanner_model"]) -> typing.Union[MetaOapg.properties.scanner_model, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["field_strength"]) -> typing.Union[MetaOapg.properties.field_strength, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["pulse_sequence"]) -> typing.Union[MetaOapg.properties.pulse_sequence, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["parallel_imaging"]) -> typing.Union[MetaOapg.properties.parallel_imaging, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["field_of_view"]) -> typing.Union[MetaOapg.properties.field_of_view, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["matrix_size"]) -> typing.Union[MetaOapg.properties.matrix_size, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["slice_thickness"]) -> typing.Union[MetaOapg.properties.slice_thickness, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["skip_distance"]) -> typing.Union[MetaOapg.properties.skip_distance, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["acquisition_orientation"]) -> typing.Union[MetaOapg.properties.acquisition_orientation, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["order_of_acquisition"]) -> typing.Union[MetaOapg.properties.order_of_acquisition, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["repetition_time"]) -> typing.Union[MetaOapg.properties.repetition_time, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["echo_time"]) -> typing.Union[MetaOapg.properties.echo_time, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["flip_angle"]) -> typing.Union[MetaOapg.properties.flip_angle, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["software_package"]) -> typing.Union[MetaOapg.properties.software_package, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["software_version"]) -> typing.Union[MetaOapg.properties.software_version, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["order_of_preprocessing_operations"]) -> typing.Union[MetaOapg.properties.order_of_preprocessing_operations, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["quality_control"]) -> typing.Union[MetaOapg.properties.quality_control, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_b0_unwarping"]) -> typing.Union[MetaOapg.properties.used_b0_unwarping, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["b0_unwarping_software"]) -> typing.Union[MetaOapg.properties.b0_unwarping_software, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_slice_timing_correction"]) -> typing.Union[MetaOapg.properties.used_slice_timing_correction, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["slice_timing_correction_software"]) -> typing.Union[MetaOapg.properties.slice_timing_correction_software, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_motion_correction"]) -> typing.Union[MetaOapg.properties.used_motion_correction, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["motion_correction_software"]) -> typing.Union[MetaOapg.properties.motion_correction_software, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["motion_correction_reference"]) -> typing.Union[MetaOapg.properties.motion_correction_reference, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["motion_correction_metric"]) -> typing.Union[MetaOapg.properties.motion_correction_metric, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["motion_correction_interpolation"]) -> typing.Union[MetaOapg.properties.motion_correction_interpolation, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_motion_susceptibiity_correction"]) -> typing.Union[MetaOapg.properties.used_motion_susceptibiity_correction, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_intersubject_registration"]) -> typing.Union[MetaOapg.properties.used_intersubject_registration, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["intersubject_registration_software"]) -> typing.Union[MetaOapg.properties.intersubject_registration_software, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["intersubject_transformation_type"]) -> typing.Union[MetaOapg.properties.intersubject_transformation_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["nonlinear_transform_type"]) -> typing.Union[MetaOapg.properties.nonlinear_transform_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["transform_similarity_metric"]) -> typing.Union[MetaOapg.properties.transform_similarity_metric, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["interpolation_method"]) -> typing.Union[MetaOapg.properties.interpolation_method, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["object_image_type"]) -> typing.Union[MetaOapg.properties.object_image_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["functional_coregistered_to_structural"]) -> typing.Union[MetaOapg.properties.functional_coregistered_to_structural, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["functional_coregistration_method"]) -> typing.Union[MetaOapg.properties.functional_coregistration_method, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["coordinate_space"]) -> typing.Union[MetaOapg.properties.coordinate_space, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["target_template_image"]) -> typing.Union[MetaOapg.properties.target_template_image, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["target_resolution"]) -> typing.Union[MetaOapg.properties.target_resolution, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_smoothing"]) -> typing.Union[MetaOapg.properties.used_smoothing, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["smoothing_type"]) -> typing.Union[MetaOapg.properties.smoothing_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["smoothing_fwhm"]) -> typing.Union[MetaOapg.properties.smoothing_fwhm, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["resampled_voxel_size"]) -> typing.Union[MetaOapg.properties.resampled_voxel_size, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["intrasubject_model_type"]) -> typing.Union[MetaOapg.properties.intrasubject_model_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["intrasubject_estimation_type"]) -> typing.Union[MetaOapg.properties.intrasubject_estimation_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["intrasubject_modeling_software"]) -> typing.Union[MetaOapg.properties.intrasubject_modeling_software, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["hemodynamic_response_function"]) -> typing.Union[MetaOapg.properties.hemodynamic_response_function, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_temporal_derivatives"]) -> typing.Union[MetaOapg.properties.used_temporal_derivatives, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_dispersion_derivatives"]) -> typing.Union[MetaOapg.properties.used_dispersion_derivatives, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_motion_regressors"]) -> typing.Union[MetaOapg.properties.used_motion_regressors, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_reaction_time_regressor"]) -> typing.Union[MetaOapg.properties.used_reaction_time_regressor, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_orthogonalization"]) -> typing.Union[MetaOapg.properties.used_orthogonalization, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["orthogonalization_description"]) -> typing.Union[MetaOapg.properties.orthogonalization_description, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["used_high_pass_filter"]) -> typing.Union[MetaOapg.properties.used_high_pass_filter, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["high_pass_filter_method"]) -> typing.Union[MetaOapg.properties.high_pass_filter_method, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["autocorrelation_model"]) -> typing.Union[MetaOapg.properties.autocorrelation_model, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_model_type"]) -> typing.Union[MetaOapg.properties.group_model_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_estimation_type"]) -> typing.Union[MetaOapg.properties.group_estimation_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_modeling_software"]) -> typing.Union[MetaOapg.properties.group_modeling_software, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_inference_type"]) -> typing.Union[MetaOapg.properties.group_inference_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_model_multilevel"]) -> typing.Union[MetaOapg.properties.group_model_multilevel, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_repeated_measures"]) -> typing.Union[MetaOapg.properties.group_repeated_measures, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["group_repeated_measures_method"]) -> typing.Union[MetaOapg.properties.group_repeated_measures_method, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["nutbrain_hunger_state"]) -> typing.Union[MetaOapg.properties.nutbrain_hunger_state, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["nutbrain_food_viewing_conditions"]) -> typing.Union[MetaOapg.properties.nutbrain_food_viewing_conditions, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["nutbrain_food_choice_type"]) -> typing.Union[MetaOapg.properties.nutbrain_food_choice_type, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["nutbrain_taste_conditions"]) -> typing.Union[MetaOapg.properties.nutbrain_taste_conditions, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["nutbrain_odor_conditions"]) -> typing.Union[MetaOapg.properties.nutbrain_odor_conditions, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["communities"]) -> typing.Union[MetaOapg.properties.communities, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "url", "download_url", "owner", "contributors", "owner_name", "number_of_images", "name", "DOI", "authors", "paper_url", "journal_name", "description", "full_dataset_url", "private", "add_date", "modify_date", "doi_add_date", "type_of_design", "number_of_imaging_runs", "number_of_experimental_units", "length_of_runs", "length_of_blocks", "length_of_trials", "optimization", "optimization_method", "subject_age_mean", "subject_age_min", "subject_age_max", "handedness", "proportion_male_subjects", "inclusion_exclusion_criteria", "number_of_rejected_subjects", "group_comparison", "group_description", "scanner_make", "scanner_model", "field_strength", "pulse_sequence", "parallel_imaging", "field_of_view", "matrix_size", "slice_thickness", "skip_distance", "acquisition_orientation", "order_of_acquisition", "repetition_time", "echo_time", "flip_angle", "software_package", "software_version", "order_of_preprocessing_operations", "quality_control", "used_b0_unwarping", "b0_unwarping_software", "used_slice_timing_correction", "slice_timing_correction_software", "used_motion_correction", "motion_correction_software", "motion_correction_reference", "motion_correction_metric", "motion_correction_interpolation", "used_motion_susceptibiity_correction", "used_intersubject_registration", "intersubject_registration_software", "intersubject_transformation_type", "nonlinear_transform_type", "transform_similarity_metric", "interpolation_method", "object_image_type", "functional_coregistered_to_structural", "functional_coregistration_method", "coordinate_space", "target_template_image", "target_resolution", "used_smoothing", "smoothing_type", "smoothing_fwhm", "resampled_voxel_size", "intrasubject_model_type", "intrasubject_estimation_type", "intrasubject_modeling_software", "hemodynamic_response_function", "used_temporal_derivatives", "used_dispersion_derivatives", "used_motion_regressors", "used_reaction_time_regressor", "used_orthogonalization", "orthogonalization_description", "used_high_pass_filter", "high_pass_filter_method", "autocorrelation_model", "group_model_type", "group_estimation_type", "group_modeling_software", "group_inference_type", "group_model_multilevel", "group_repeated_measures", "group_repeated_measures_method", "nutbrain_hunger_state", "nutbrain_food_viewing_conditions", "nutbrain_food_choice_type", "nutbrain_taste_conditions", "nutbrain_odor_conditions", "communities", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *args: typing.Union[dict, frozendict.frozendict, ],
        id: typing.Union[MetaOapg.properties.id, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        url: typing.Union[MetaOapg.properties.url, str, schemas.Unset] = schemas.unset,
        download_url: typing.Union[MetaOapg.properties.download_url, str, schemas.Unset] = schemas.unset,
        owner: typing.Union[MetaOapg.properties.owner, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        contributors: typing.Union[MetaOapg.properties.contributors, str, schemas.Unset] = schemas.unset,
        owner_name: typing.Union[MetaOapg.properties.owner_name, str, schemas.Unset] = schemas.unset,
        number_of_images: typing.Union[MetaOapg.properties.number_of_images, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
        DOI: typing.Union[MetaOapg.properties.DOI, None, str, schemas.Unset] = schemas.unset,
        authors: typing.Union[MetaOapg.properties.authors, None, str, schemas.Unset] = schemas.unset,
        paper_url: typing.Union[MetaOapg.properties.paper_url, None, str, schemas.Unset] = schemas.unset,
        journal_name: typing.Union[MetaOapg.properties.journal_name, None, str, schemas.Unset] = schemas.unset,
        description: typing.Union[MetaOapg.properties.description, None, str, schemas.Unset] = schemas.unset,
        full_dataset_url: typing.Union[MetaOapg.properties.full_dataset_url, None, str, schemas.Unset] = schemas.unset,
        private: typing.Union[MetaOapg.properties.private, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        add_date: typing.Union[MetaOapg.properties.add_date, str, datetime, schemas.Unset] = schemas.unset,
        modify_date: typing.Union[MetaOapg.properties.modify_date, str, datetime, schemas.Unset] = schemas.unset,
        doi_add_date: typing.Union[MetaOapg.properties.doi_add_date, None, str, datetime, schemas.Unset] = schemas.unset,
        type_of_design: typing.Union[MetaOapg.properties.type_of_design, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        number_of_imaging_runs: typing.Union[MetaOapg.properties.number_of_imaging_runs, None, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        number_of_experimental_units: typing.Union[MetaOapg.properties.number_of_experimental_units, None, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        length_of_runs: typing.Union[MetaOapg.properties.length_of_runs, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        length_of_blocks: typing.Union[MetaOapg.properties.length_of_blocks, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        length_of_trials: typing.Union[MetaOapg.properties.length_of_trials, None, str, schemas.Unset] = schemas.unset,
        optimization: typing.Union[MetaOapg.properties.optimization, None, bool, schemas.Unset] = schemas.unset,
        optimization_method: typing.Union[MetaOapg.properties.optimization_method, None, str, schemas.Unset] = schemas.unset,
        subject_age_mean: typing.Union[MetaOapg.properties.subject_age_mean, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        subject_age_min: typing.Union[MetaOapg.properties.subject_age_min, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        subject_age_max: typing.Union[MetaOapg.properties.subject_age_max, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        handedness: typing.Union[MetaOapg.properties.handedness, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        proportion_male_subjects: typing.Union[MetaOapg.properties.proportion_male_subjects, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        inclusion_exclusion_criteria: typing.Union[MetaOapg.properties.inclusion_exclusion_criteria, None, str, schemas.Unset] = schemas.unset,
        number_of_rejected_subjects: typing.Union[MetaOapg.properties.number_of_rejected_subjects, None, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        group_comparison: typing.Union[MetaOapg.properties.group_comparison, None, bool, schemas.Unset] = schemas.unset,
        group_description: typing.Union[MetaOapg.properties.group_description, None, str, schemas.Unset] = schemas.unset,
        scanner_make: typing.Union[MetaOapg.properties.scanner_make, None, str, schemas.Unset] = schemas.unset,
        scanner_model: typing.Union[MetaOapg.properties.scanner_model, None, str, schemas.Unset] = schemas.unset,
        field_strength: typing.Union[MetaOapg.properties.field_strength, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        pulse_sequence: typing.Union[MetaOapg.properties.pulse_sequence, None, str, schemas.Unset] = schemas.unset,
        parallel_imaging: typing.Union[MetaOapg.properties.parallel_imaging, None, str, schemas.Unset] = schemas.unset,
        field_of_view: typing.Union[MetaOapg.properties.field_of_view, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        matrix_size: typing.Union[MetaOapg.properties.matrix_size, None, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        slice_thickness: typing.Union[MetaOapg.properties.slice_thickness, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        skip_distance: typing.Union[MetaOapg.properties.skip_distance, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        acquisition_orientation: typing.Union[MetaOapg.properties.acquisition_orientation, None, str, schemas.Unset] = schemas.unset,
        order_of_acquisition: typing.Union[MetaOapg.properties.order_of_acquisition, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        repetition_time: typing.Union[MetaOapg.properties.repetition_time, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        echo_time: typing.Union[MetaOapg.properties.echo_time, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        flip_angle: typing.Union[MetaOapg.properties.flip_angle, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        software_package: typing.Union[MetaOapg.properties.software_package, None, str, schemas.Unset] = schemas.unset,
        software_version: typing.Union[MetaOapg.properties.software_version, None, str, schemas.Unset] = schemas.unset,
        order_of_preprocessing_operations: typing.Union[MetaOapg.properties.order_of_preprocessing_operations, None, str, schemas.Unset] = schemas.unset,
        quality_control: typing.Union[MetaOapg.properties.quality_control, None, str, schemas.Unset] = schemas.unset,
        used_b0_unwarping: typing.Union[MetaOapg.properties.used_b0_unwarping, None, bool, schemas.Unset] = schemas.unset,
        b0_unwarping_software: typing.Union[MetaOapg.properties.b0_unwarping_software, None, str, schemas.Unset] = schemas.unset,
        used_slice_timing_correction: typing.Union[MetaOapg.properties.used_slice_timing_correction, None, bool, schemas.Unset] = schemas.unset,
        slice_timing_correction_software: typing.Union[MetaOapg.properties.slice_timing_correction_software, None, str, schemas.Unset] = schemas.unset,
        used_motion_correction: typing.Union[MetaOapg.properties.used_motion_correction, None, bool, schemas.Unset] = schemas.unset,
        motion_correction_software: typing.Union[MetaOapg.properties.motion_correction_software, None, str, schemas.Unset] = schemas.unset,
        motion_correction_reference: typing.Union[MetaOapg.properties.motion_correction_reference, None, str, schemas.Unset] = schemas.unset,
        motion_correction_metric: typing.Union[MetaOapg.properties.motion_correction_metric, None, str, schemas.Unset] = schemas.unset,
        motion_correction_interpolation: typing.Union[MetaOapg.properties.motion_correction_interpolation, None, str, schemas.Unset] = schemas.unset,
        used_motion_susceptibiity_correction: typing.Union[MetaOapg.properties.used_motion_susceptibiity_correction, None, bool, schemas.Unset] = schemas.unset,
        used_intersubject_registration: typing.Union[MetaOapg.properties.used_intersubject_registration, None, bool, schemas.Unset] = schemas.unset,
        intersubject_registration_software: typing.Union[MetaOapg.properties.intersubject_registration_software, None, str, schemas.Unset] = schemas.unset,
        intersubject_transformation_type: typing.Union[MetaOapg.properties.intersubject_transformation_type, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        nonlinear_transform_type: typing.Union[MetaOapg.properties.nonlinear_transform_type, None, str, schemas.Unset] = schemas.unset,
        transform_similarity_metric: typing.Union[MetaOapg.properties.transform_similarity_metric, None, str, schemas.Unset] = schemas.unset,
        interpolation_method: typing.Union[MetaOapg.properties.interpolation_method, None, str, schemas.Unset] = schemas.unset,
        object_image_type: typing.Union[MetaOapg.properties.object_image_type, None, str, schemas.Unset] = schemas.unset,
        functional_coregistered_to_structural: typing.Union[MetaOapg.properties.functional_coregistered_to_structural, None, bool, schemas.Unset] = schemas.unset,
        functional_coregistration_method: typing.Union[MetaOapg.properties.functional_coregistration_method, None, str, schemas.Unset] = schemas.unset,
        coordinate_space: typing.Union[MetaOapg.properties.coordinate_space, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        target_template_image: typing.Union[MetaOapg.properties.target_template_image, None, str, schemas.Unset] = schemas.unset,
        target_resolution: typing.Union[MetaOapg.properties.target_resolution, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        used_smoothing: typing.Union[MetaOapg.properties.used_smoothing, None, bool, schemas.Unset] = schemas.unset,
        smoothing_type: typing.Union[MetaOapg.properties.smoothing_type, None, str, schemas.Unset] = schemas.unset,
        smoothing_fwhm: typing.Union[MetaOapg.properties.smoothing_fwhm, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        resampled_voxel_size: typing.Union[MetaOapg.properties.resampled_voxel_size, None, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
        intrasubject_model_type: typing.Union[MetaOapg.properties.intrasubject_model_type, None, str, schemas.Unset] = schemas.unset,
        intrasubject_estimation_type: typing.Union[MetaOapg.properties.intrasubject_estimation_type, None, str, schemas.Unset] = schemas.unset,
        intrasubject_modeling_software: typing.Union[MetaOapg.properties.intrasubject_modeling_software, None, str, schemas.Unset] = schemas.unset,
        hemodynamic_response_function: typing.Union[MetaOapg.properties.hemodynamic_response_function, None, str, schemas.Unset] = schemas.unset,
        used_temporal_derivatives: typing.Union[MetaOapg.properties.used_temporal_derivatives, None, bool, schemas.Unset] = schemas.unset,
        used_dispersion_derivatives: typing.Union[MetaOapg.properties.used_dispersion_derivatives, None, bool, schemas.Unset] = schemas.unset,
        used_motion_regressors: typing.Union[MetaOapg.properties.used_motion_regressors, None, bool, schemas.Unset] = schemas.unset,
        used_reaction_time_regressor: typing.Union[MetaOapg.properties.used_reaction_time_regressor, None, bool, schemas.Unset] = schemas.unset,
        used_orthogonalization: typing.Union[MetaOapg.properties.used_orthogonalization, None, bool, schemas.Unset] = schemas.unset,
        orthogonalization_description: typing.Union[MetaOapg.properties.orthogonalization_description, None, str, schemas.Unset] = schemas.unset,
        used_high_pass_filter: typing.Union[MetaOapg.properties.used_high_pass_filter, None, bool, schemas.Unset] = schemas.unset,
        high_pass_filter_method: typing.Union[MetaOapg.properties.high_pass_filter_method, None, str, schemas.Unset] = schemas.unset,
        autocorrelation_model: typing.Union[MetaOapg.properties.autocorrelation_model, None, str, schemas.Unset] = schemas.unset,
        group_model_type: typing.Union[MetaOapg.properties.group_model_type, None, str, schemas.Unset] = schemas.unset,
        group_estimation_type: typing.Union[MetaOapg.properties.group_estimation_type, None, str, schemas.Unset] = schemas.unset,
        group_modeling_software: typing.Union[MetaOapg.properties.group_modeling_software, None, str, schemas.Unset] = schemas.unset,
        group_inference_type: typing.Union[MetaOapg.properties.group_inference_type, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        group_model_multilevel: typing.Union[MetaOapg.properties.group_model_multilevel, None, str, schemas.Unset] = schemas.unset,
        group_repeated_measures: typing.Union[MetaOapg.properties.group_repeated_measures, None, bool, schemas.Unset] = schemas.unset,
        group_repeated_measures_method: typing.Union[MetaOapg.properties.group_repeated_measures_method, None, str, schemas.Unset] = schemas.unset,
        nutbrain_hunger_state: typing.Union[MetaOapg.properties.nutbrain_hunger_state, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        nutbrain_food_viewing_conditions: typing.Union[MetaOapg.properties.nutbrain_food_viewing_conditions, None, str, schemas.Unset] = schemas.unset,
        nutbrain_food_choice_type: typing.Union[MetaOapg.properties.nutbrain_food_choice_type, None, str, schemas.Unset] = schemas.unset,
        nutbrain_taste_conditions: typing.Union[MetaOapg.properties.nutbrain_taste_conditions, None, str, schemas.Unset] = schemas.unset,
        nutbrain_odor_conditions: typing.Union[MetaOapg.properties.nutbrain_odor_conditions, None, str, schemas.Unset] = schemas.unset,
        communities: typing.Union[MetaOapg.properties.communities, list, tuple, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'PatchedCollection':
        return super().__new__(
            cls,
            *args,
            id=id,
            url=url,
            download_url=download_url,
            owner=owner,
            contributors=contributors,
            owner_name=owner_name,
            number_of_images=number_of_images,
            name=name,
            DOI=DOI,
            authors=authors,
            paper_url=paper_url,
            journal_name=journal_name,
            description=description,
            full_dataset_url=full_dataset_url,
            private=private,
            add_date=add_date,
            modify_date=modify_date,
            doi_add_date=doi_add_date,
            type_of_design=type_of_design,
            number_of_imaging_runs=number_of_imaging_runs,
            number_of_experimental_units=number_of_experimental_units,
            length_of_runs=length_of_runs,
            length_of_blocks=length_of_blocks,
            length_of_trials=length_of_trials,
            optimization=optimization,
            optimization_method=optimization_method,
            subject_age_mean=subject_age_mean,
            subject_age_min=subject_age_min,
            subject_age_max=subject_age_max,
            handedness=handedness,
            proportion_male_subjects=proportion_male_subjects,
            inclusion_exclusion_criteria=inclusion_exclusion_criteria,
            number_of_rejected_subjects=number_of_rejected_subjects,
            group_comparison=group_comparison,
            group_description=group_description,
            scanner_make=scanner_make,
            scanner_model=scanner_model,
            field_strength=field_strength,
            pulse_sequence=pulse_sequence,
            parallel_imaging=parallel_imaging,
            field_of_view=field_of_view,
            matrix_size=matrix_size,
            slice_thickness=slice_thickness,
            skip_distance=skip_distance,
            acquisition_orientation=acquisition_orientation,
            order_of_acquisition=order_of_acquisition,
            repetition_time=repetition_time,
            echo_time=echo_time,
            flip_angle=flip_angle,
            software_package=software_package,
            software_version=software_version,
            order_of_preprocessing_operations=order_of_preprocessing_operations,
            quality_control=quality_control,
            used_b0_unwarping=used_b0_unwarping,
            b0_unwarping_software=b0_unwarping_software,
            used_slice_timing_correction=used_slice_timing_correction,
            slice_timing_correction_software=slice_timing_correction_software,
            used_motion_correction=used_motion_correction,
            motion_correction_software=motion_correction_software,
            motion_correction_reference=motion_correction_reference,
            motion_correction_metric=motion_correction_metric,
            motion_correction_interpolation=motion_correction_interpolation,
            used_motion_susceptibiity_correction=used_motion_susceptibiity_correction,
            used_intersubject_registration=used_intersubject_registration,
            intersubject_registration_software=intersubject_registration_software,
            intersubject_transformation_type=intersubject_transformation_type,
            nonlinear_transform_type=nonlinear_transform_type,
            transform_similarity_metric=transform_similarity_metric,
            interpolation_method=interpolation_method,
            object_image_type=object_image_type,
            functional_coregistered_to_structural=functional_coregistered_to_structural,
            functional_coregistration_method=functional_coregistration_method,
            coordinate_space=coordinate_space,
            target_template_image=target_template_image,
            target_resolution=target_resolution,
            used_smoothing=used_smoothing,
            smoothing_type=smoothing_type,
            smoothing_fwhm=smoothing_fwhm,
            resampled_voxel_size=resampled_voxel_size,
            intrasubject_model_type=intrasubject_model_type,
            intrasubject_estimation_type=intrasubject_estimation_type,
            intrasubject_modeling_software=intrasubject_modeling_software,
            hemodynamic_response_function=hemodynamic_response_function,
            used_temporal_derivatives=used_temporal_derivatives,
            used_dispersion_derivatives=used_dispersion_derivatives,
            used_motion_regressors=used_motion_regressors,
            used_reaction_time_regressor=used_reaction_time_regressor,
            used_orthogonalization=used_orthogonalization,
            orthogonalization_description=orthogonalization_description,
            used_high_pass_filter=used_high_pass_filter,
            high_pass_filter_method=high_pass_filter_method,
            autocorrelation_model=autocorrelation_model,
            group_model_type=group_model_type,
            group_estimation_type=group_estimation_type,
            group_modeling_software=group_modeling_software,
            group_inference_type=group_inference_type,
            group_model_multilevel=group_model_multilevel,
            group_repeated_measures=group_repeated_measures,
            group_repeated_measures_method=group_repeated_measures_method,
            nutbrain_hunger_state=nutbrain_hunger_state,
            nutbrain_food_viewing_conditions=nutbrain_food_viewing_conditions,
            nutbrain_food_choice_type=nutbrain_food_choice_type,
            nutbrain_taste_conditions=nutbrain_taste_conditions,
            nutbrain_odor_conditions=nutbrain_odor_conditions,
            communities=communities,
            _configuration=_configuration,
            **kwargs,
        )

from neurovault_sdk.model.blank_enum import BlankEnum
from neurovault_sdk.model.collection_handedness_enum import CollectionHandednessEnum
from neurovault_sdk.model.coordinate_space_enum import CoordinateSpaceEnum
from neurovault_sdk.model.group_inference_type_enum import GroupInferenceTypeEnum
from neurovault_sdk.model.intersubject_transformation_type_enum import IntersubjectTransformationTypeEnum
from neurovault_sdk.model.null_enum import NullEnum
from neurovault_sdk.model.nutbrain_hunger_state_enum import NutbrainHungerStateEnum
from neurovault_sdk.model.order_of_acquisition_enum import OrderOfAcquisitionEnum
from neurovault_sdk.model.private_enum import PrivateEnum
from neurovault_sdk.model.type_of_design_enum import TypeOfDesignEnum
